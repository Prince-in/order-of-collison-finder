# order-of-collison-finder

Problem StatementInspired  by  the surprising  connection  between  the  number of  collisions  and  the numberπ,  we  would  liketo  solve  a  more  general  problem  –  only  computationally.   Consider  a  set  ofnpoint  objects  located  in  agravity-free one-dimensional universe, where fori∈{0,...,n−1}, thei’th object has massmi∈R, and attimet= 0, it is located at positionxi∈Rand has velocityvi∈R.  Assume that the objects are numberedfrom left to right, that is,x0< x1<···< xn−1.  Given this initial conditions, the objects undergo severalcollisions over time and eventually move away from one another.  Recall that since there is no external forceinvolved, by Newton’s law, the total momentum of the objects is conserved during every collision.  Assumethat each collision is elastic, and therefore, kinetic energy is conserved too.  Also, note that no two objectscan ever “cross” each other, and therefore, collisions can happen only between objectsiandi+ 1, for somei∈{0,...,n−2}.We represent a collision by a tuple of a real number, an integer, and another real number.  The tuple(t,i,x) represents a collision happening at timetbetween objectsiandi+ 1 at locationx.  Given a list ofmasses, a list of initial positions, and a list of initial velocities, each having the same sizen, our goal is toenumerate the resulting collisions in a chronological order.  Ties between collisions happening at the sametime must be broken from left to right.  For example fori < i′, if at timet, objecticollides withi+ 1 atlocationx, andi′collides withi′+ 1 at locationx′, then the collision (t,i,x) must precede (t,i′,x′).  Youmay assume that the input is such that no more than 2 objects collide at the same time and the same place.Your task is to write aPythonfunctionlistCollisionsthat takes the following five arguments:1.M: a list of positive floats, whereM[i]is the mass of thei’th object,2.x:  a sorted list of floats, wherex[i]is the initial position of thei’th object,3.v:  a list of floats, wherev[i]is the initial velocity of thei’th object,4.m:  a non-negative integer,5.T: a non-negative float,and returns a list of collisions in chronological order that ends as soon as the firstmcollisions happen ortime  reachesT(whichever  earlier).   If  the  input  results  in  fewer  thanmcollisions  and  the  last  collisionhappens before timeT, the list returned must contain all collisions in chronological order.  Recall that weare representing each collision by a 3-tuple, as mentioned earlier.  Round thetandxvalues of collisions to4 decimal digits.  (However, note that you should still use the exact values, rather than the rounded ones,in your subsequent calculations to avoid accumulating errors.)  You may assume that the listsM,x,vhavethe same size.  Identify all the necessary data structures and implement their methods from scratch.  For fullcredit, your functionlistCollisionsmust run in timeO(n+mlogn).Here is a helpful reference:  the formula to find velocities after an elastic collision, given the masses oftwo colliding objects and their velocities before collision.Submission SpecificationsSubmit a single file nameda2.py.  Your submitted file must contain a functionlistCollisions(M,x,v,m,T)that takes three lists of floats, an integer, and a float as arguments. The function must return a list of 3-tuples,each representing a collision.Example Test Cases>>> listCollisions([1.0, 5.0], [1.0, 2.0], [3.0, 5.0], 100, 100.0)[]>>> listCollisions([1.0, 1.0, 1.0, 1.0], [-2.0, -1.0, 1.0, 2.0], [0.0, -1.0, 1.0, 0.0], 5,5.0)
